## **全部最终文件代码 (All Final File Code)**

### **根目录文件**

#### **文件: `/Thanatos/.gitignore`**
```.gitignore
# IDE
.idea/
.vscode/
*.iml
*.ipr
*.iws

# Android Studio
/local.properties
/.gradle/
/build/
/app/build/
*.apk
*.aab

# C/C++
*.o
*.a
*.so
*.lo
*.la
*.dll
*.exe
*.out

# CMake
/cmake-build-*/
/CMakeCache.txt
/CMakeFiles/
/cmake_install.cmake

# Rust
/target/
/daemon/rust/Cargo.lock

# Distribution
/release/

# Logs
*.log

# OS
.DS_Store
Thumbs.db
```

#### **文件: `/Thanatos/build.gradle.kts`**
```kotlin
// 文件路径: /Thanatos/build.gradle.kts

// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    id("com.android.application") version "8.2.2" apply false
    id("org.jetbrains.kotlin.android") version "1.9.22" apply false
    // 添加 Hilt 插件
    id("com.google.dagger.hilt.android") version "2.51" apply false
    // 添加 Protobuf 插件
    id("com.google.protobuf") version "0.9.4" apply false
}
```

#### **文件: `/Thanatos/settings.gradle.kts`**
```kotlin
// 文件路径: /Thanatos/settings.gradle.kts

pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "Thanatos"
include(":app")
```

#### **文件: `/Thanatos/package_magisk.sh`**
```bash
#!/bin/bash
# 文件路径: /Thanatos/package_magisk.sh

# Stop on error
set -e

PROJECT_ROOT=$(pwd)
MODULE_ID="thanatos-core"
BUILD_DIR="$PROJECT_ROOT/daemon/build"
OUTPUT_DIR="$PROJECT_ROOT/release"
MODULE_SRC_DIR="$PROJECT_ROOT/magisk"
DAEMON_BINARY="$BUILD_DIR/thanatosd"

echo "--- Thanatos Magisk Module Packager ---"

# 1. Check if daemon binary exists
if [ ! -f "$DAEMON_BINARY" ]; then
    echo "Error: Daemon binary not found at $DAEMON_BINARY"
    echo "Please build the daemon first by running 'ninja' in '$BUILD_DIR'"
    exit 1
fi

echo "Daemon binary found."

# 2. Create temporary packaging directory
TMP_DIR=$(mktemp -d)
echo "Using temporary directory: $TMP_DIR"

# 3. Create module structure
echo "Creating Magisk module structure..."
mkdir -p "$TMP_DIR/system/bin"

# 4. Copy files
echo "Copying files..."
# Copy module metadata and scripts
cp -r "$MODULE_SRC_DIR/"* "$TMP_DIR/"
echo "Copied module scripts and metadata."

# Copy the compiled daemon binary
cp "$DAEMON_BINARY" "$TMP_DIR/system/bin/"
echo "Copied 'thanatosd' binary."

# 5. Zip the module
echo "Zipping module..."
mkdir -p "$OUTPUT_DIR"
OUTPUT_ZIP="$OUTPUT_DIR/Thanatos-Module-$(date +%Y%m%d-%H%M).zip"
cd "$TMP_DIR"
zip -r9 "$OUTPUT_ZIP" .
cd "$PROJECT_ROOT"

# 6. Clean up
echo "Cleaning up temporary directory..."
rm -rf "$TMP_DIR"

echo "---"
echo "Success! Module created at: $OUTPUT_ZIP"
echo "---"
```

### **`ipc` 目录**

#### **文件: `/Thanatos/ipc/proto/thanatos.proto`**
```protobuf
// 文件路径: /Thanatos/ipc/proto/thanatos.proto

syntax = "proto3";

package thanatos.ipc;

import "google/protobuf/empty.proto";

// --- Enums ---
enum ManagementPolicy {
  POLICY_UNSPECIFIED = 0;
  UNMANAGED = 1;
  LENIENT_BACKGROUND = 2;
  STRICT_BACKGROUND = 3;
  AI_MANAGED = 4;
}

enum FreezeMode {
  MODE_UNSPECIFIED = 0;
  MODE_SIGSTOP = 1;
  MODE_KILL = 2;
  MODE_HIBERNATE = 3;
}

enum NetworkPolicy {
  NET_POLICY_UNSPECIFIED = 0;
  ALLOW_ALL = 1;
  WIFI_ONLY = 2;
  BLOCK_ALL = 3;
}

enum OomPriority {
  OOM_UNSPECIFIED = 0;
  OOM_DEFAULT = 1;
  OOM_HIGH = 2; // Less likely to be killed
  OOM_MEDIUM = 3;
  OOM_LOW = 4; // More likely to be killed
}

enum ComponentType {
  COMP_UNSPECIFIED = 0;
  COMP_SERVICE = 1;
  COMP_RECEIVER = 2;
  COMP_ACTIVITY = 3;
  COMP_PROVIDER = 4;
}

enum UnfreezeReason {
  REASON_UNSPECIFIED = 0;
  FCM_PUSH = 1;
  SYSTEM_ALARM = 2;
  USER_REQUEST = 3;
  AI_PREDICTION = 4;
  ASSOCIATED_START = 5;
}

// --- Messages ---
message AppConfig {
  string package_name = 1;
  ManagementPolicy policy = 2;
  FreezeMode freeze_mode = 3;
  OomPriority oom_priority = 4;
  NetworkPolicy network_policy = 5;
  bool allow_wakeup_for_push = 7;
  bool allow_autostart = 8;
}

message ComponentInfo {
  string package_name = 1;
  string class_name = 2;
  ComponentType type = 3;
  bool enabled = 4;
}

message LaunchRule {
  string source_package = 1;
  string target_package = 2;
  bool allowed = 3;
}

message EventLog {
  int64 timestamp = 1;
  string package_name = 2;
  string event_description = 3;
}

message RuntimeStats {
  int64 total_mem_kb = 1;
  int64 avail_mem_kb = 2;
  int32 frozen_app_count = 3;
  float cpu_usage_percent = 4;
  int64 network_speed_bps = 5;
}

message FrameworkEvent {
    enum EventType {
        TYPE_UNSPECIFIED = 0;
        SCREEN_ON = 1;
        SCREEN_OFF = 2;
        APP_FOREGROUND = 3;
        APP_BACKGROUND = 4;
        FCM_WAKEUP = 5;
    }
    EventType event_type = 1;
    string source_package = 2; // For APP events, this is PID.
    string target_package = 3; // For APP events, this is the package name.
    int64 timestamp = 4;
}

message TempUnfreezeRequest {
  string package_name = 1;
  UnfreezeReason reason = 2;
  int32 duration_ms = 3; // 0 means until next screen off
}

// --- Services ---
service AppControlService { // App <-> Daemon
  rpc SetAppConfig(AppConfig) returns (google.protobuf.Empty);
  rpc GetAllConfigs(google.protobuf.Empty) returns (stream AppConfig);
  rpc GetComponents(ComponentInfo) returns (stream ComponentInfo);
  rpc SetComponentEnabled(ComponentInfo) returns (google.protobuf.Empty);
  rpc GetLaunchRules(google.protobuf.Empty) returns (stream LaunchRule);
  rpc SetLaunchRule(LaunchRule) returns (google.protobuf.Empty);
}

service SystemService { // Sensor <-> Daemon
  rpc PushFrameworkEvents(stream FrameworkEvent) returns (google.protobuf.Empty);
  rpc RequestTemporaryUnfreeze(TempUnfreezeRequest) returns (google.protobuf.Empty);
  rpc ShouldAllowLaunch(LaunchRule) returns (LaunchRule);
}

service DashboardService { // App <-> Daemon
  rpc StreamRuntimeStats(google.protobuf.Empty) returns (stream RuntimeStats);
  rpc GetRecentEvents(google.protobuf.Empty) returns (stream EventLog);
}
```

### **`magisk` 目录**

#### **文件: `/Thanatos/magisk/module.prop`**
```properties
# 文件路径: /Thanatos/magisk/module.prop
id=thanatos-core
name=Thanatos Core Service
version=v2.0.0
versionCode=200
author=Jark
description=The core daemon for Thanatos system orchestrator. Manages app lifecycle, intercepts wakelocks, and provides system stats.
support=https://github.com/jark006/Thanatos
```

#### **文件: `/Thanatos/magisk/customize.sh`**
```bash
#!/system/bin/sh
# 文件路径: /Thanatos/magisk/customize.sh

# This script is executed during the Magisk module installation

# 1. A's a root user, Magisk will extract the module files to $MODPATH
#    This script has access to utility functions defined by Magisk.
#    ui_print, set_perm, set_perm_recursive, etc.

ui_print "*******************************"
ui_print " Thanatos Core Service Installer "
ui_print "*******************************"

# 2. Set permissions for the daemon binary
ui_print "- Setting permissions for thanatosd..."
# Set executable permissions (rwxr-xr-x) for the daemon
# Owner: root (0), Group: root (0)
set_perm_recursive $MODPATH/system/bin 755 0 0

# 3. Handle SELinux policies
# Magisk v21+ automatically handles sepolicy.rule files.
# We just need to ensure the file exists.
if [ -f "$MODPATH/sepolicy.rule" ]; then
  ui_print "- SELinux policies will be applied on next reboot."
else
  ui_print "- No sepolicy.rule file found, skipping SELinux patching."
fi

ui_print "- Installation complete."
ui_print "- Please reboot your device to activate Thanatos."
```

#### **文件: `/Thanatos/magisk/service.sh`**
```bash
#!/system/bin/sh
# 文件路径: /Thanatos/magisk/service.sh

# This script is executed by Magisk post-fs-data or late_start service mode.
# We use late_start service mode to ensure the system is mostly booted.

# Wait until the boot process is complete to avoid race conditions.
while [ "$(getprop sys.boot_completed)" != "1" ]; do
  sleep 2
done

# The module's installation directory
MODDIR=${0%/*}

# Log file for debugging
LOGFILE=$MODDIR/thanatos.log
# Database file path
DB_PATH=$MODDIR/thanatos.db
# Socket file path
SOCKET_PATH="/data/local/tmp/thanatosd.sock"
# The daemon binary
BINARY="$MODDIR/system/bin/thanatosd"

# --- Safety Break ---
# A simple way to disable the daemon without uninstalling the module.
# Just create a file named DISABLED in the module directory.
DISABLED_FLAG="$MODDIR/DISABLED"
if [ -f "$DISABLED_FLAG" ]; then
  echo "Thanatos is disabled by flag file. Exiting." > $LOGFILE
  exit 0
fi

# Clean up old log file
rm -f $LOGFILE

# Function to start the daemon
start_daemon() {
    # Clean up any leftover socket file from a previous crash
    rm -f $SOCKET_PATH
    
    echo "Starting thanatosd daemon..." >> $LOGFILE
    echo "Binary: $BINARY" >> $LOGFILE
    echo "Socket: $SOCKET_PATH" >> $LOGFILE
    echo "Log: $LOGFILE" >> $LOGFILE
    echo "Database: $DB_PATH" >> $LOGFILE
    
    # Start the daemon in a new session to detach it from this script's lifecycle.
    # Redirect all output (stdout and stderr) to the log file.
    nohup $BINARY > $LOGFILE 2>&1 &
    
    sleep 2
    
    # Verify that the process has started
    if pgrep -f "$BINARY" >/dev/null; then
        echo "Thanatosd started successfully." >> $LOGFILE
    else
        echo "Error: Failed to start thanatosd." >> $LOGFILE
    fi
}

# Start the daemon
start_daemon
```

#### **文件: `/Thanatos/magisk/sepolicy.rule`**
```
# 文件路径: /Thanatos/magisk/sepolicy.rule

# 1. Define a new SELinux type (context) for our daemon process and its executable file.
type thanatosd, domain;
type thanatosd_exec, exec_type, file_type, vendor_file_type;

# 2. Allow the init process to transition to our daemon's domain when executing the binary.
# This is the standard way to launch a daemon with its own context.
init_daemon_domain(thanatosd)

# 3. Grant permissions for IPC via Unix Domain Socket.
# allow [source_type] [target_type]:[class] { permissions };
allow thanatosd system_data_file:dir { search write add_name };
allow thanatosd system_data_file:sock_file { create setattr read write };
allow thanatosd untrusted_app:unix_stream_socket connectto; # Allow App to connect to daemon
allow thanatosd system_server:unix_stream_socket connectto; # Allow Sensor (in system_server) to connect to daemon

# 4. Allow the daemon to execute itself.
allow thanatosd thanatosd_exec:file { read execute open execute_no_trans };

# 5. Grant permissions for process management.
allow thanatosd self:process { signal sigkill sigstop }; # Send signals to processes
allow thanatosd { app_domain system_server }:process { signal sigkill sigstop }; # Allow daemon to signal apps and system
allow thanatosd proc:file { read open write getattr }; # Access /proc/<pid>/oom_score_adj etc.
allow thanatosd proc_net:file { read open getattr }; # Access /proc/net/dev for network stats

# 6. Grant permissions to execute shell commands (like 'pm' or 'iptables').
allow thanatosd shell_exec:file rx_file_perms;
allow thanatosd system_file:file execute_no_trans;

# 7. Grant permissions to access cgroups for process state management.
allow thanatosd cgroup:dir { search read open };
allow thanatosd cgroup:file { read write open };

# 8. Grant permissions to find system services via ServiceManager (for potential future direct binder calls).
allow thanatosd app_api_service:service_manager find;
allow thanatosd system_api_service:service_manager find;
allow thanatosd activity_service:service_manager find;
allow thanatosd package_service:service_manager find;
```
---

### **`daemon` 目录**

#### **文件: `/Thanatos/daemon/CMakeLists.txt`**
```cmake
# 文件路径: /Thanatos/daemon/CMakeLists.txt

cmake_minimum_required(VERSION 3.22)

project(thanatosd LANGUAGES CXX C)

# --- 1. 全局设置 ---
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_POSITION_INDEPENDENT_CODE ON)

# --- 2. 依赖管理: gRPC, Protobuf, libev ---
include(FetchContent)

# Find libev installed on the system (e.g., via sudo apt install libev-dev)
find_package(LibEV REQUIRED)

# Fetch Protobuf from Git
FetchContent_Declare(
    protobuf
    GIT_REPOSITORY https://github.com/protocolbuffers/protobuf.git
    GIT_TAG        v21.12 # Use a stable version
)
set(protobuf_BUILD_TESTS OFF) # Don't build protobuf tests
FetchContent_MakeAvailable(protobuf)

# Fetch gRPC from Git
FetchContent_Declare(
    gRPC
    GIT_REPOSITORY https://github.com/grpc/grpc.git
    GIT_TAG        v1.49.2 # A version compatible with protobuf v21.x
)
set(gRPC_INSTALL OFF)
set(gRPC_BUILD_TESTS OFF)
set(gRPC_BUILD_CSHARP_EXT OFF)
set(gRPC_BUILD_GRPC_PHP_PLUGIN OFF)
FetchContent_MakeAvailable(gRPC)


# --- 3. 生成 Protobuf/gRPC C++ 代码 ---
get_target_property(PROTOC_EXE protobuf::protoc EXECUTABLE_LOCATION)
set(GRPC_CPP_PLUGIN_EXE $<TARGET_FILE:grpc_cpp_plugin>)

set(PROTO_FILES ${CMAKE_CURRENT_SOURCE_DIR}/../ipc/proto/thanatos.proto)
set(PROTO_INCLUDE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../ipc/proto)
set(PROTO_GEN_DIR ${CMAKE_CURRENT_BINARY_DIR}/gen/proto)

add_custom_command(
    OUTPUT ${PROTO_GEN_DIR}/thanatos.pb.cc ${PROTO_GEN_DIR}/thanatos.pb.h ${PROTO_GEN_DIR}/thanatos.grpc.pb.cc ${PROTO_GEN_DIR}/thanatos.grpc.pb.h
    COMMAND ${PROTOC_EXE}
        --grpc_out=${PROTO_GEN_DIR}
        --cpp_out=${PROTO_GEN_DIR}
        -I ${PROTO_INCLUDE_DIR}
        --plugin=protoc-gen-grpc=${GRPC_CPP_PLUGIN_EXE}
        ${PROTO_FILES}
    DEPENDS ${PROTO_FILES}
    COMMENT "Generating C++ sources from ${PROTO_FILES}"
)

add_library(thanatos_proto
    ${PROTO_GEN_DIR}/thanatos.pb.cc
    ${PROTO_GEN_DIR}/thanatos.grpc.pb.cc
)
target_include_directories(thanatos_proto PUBLIC ${PROTO_GEN_DIR})
target_link_libraries(thanatos_proto PUBLIC protobuf::libprotobuf gRPC::grpc)


# --- 4. 编译 Rust 静态库 ---
include(ExternalProject)
set(RUST_BUILD_DIR ${CMAKE_CURRENT_BINARY_DIR}/rust_build)
ExternalProject_Add(
    rust_logic_lib
    SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/rust
    CARGO_TARGET_DIR ${RUST_BUILD_DIR}
    CONFIGURE_COMMAND ""
    BUILD_COMMAND ${CMAKE_COMMAND} -E env
                  CARGO_TARGET_AARCH64_LINUX_ANDROID_LINKER=${CMAKE_CXX_COMPILER}
                  cargo build --release --target aarch64-linux-android
    INSTALL_COMMAND ""
    LOG_BUILD 1
)

set(RUST_LIBRARY_PATH ${RUST_BUILD_DIR}/aarch64-linux-android/release/libthanatos_logic.a)
set(RUST_BRIDGE_HEADER_PATH ${RUST_BUILD_DIR}/cxxbridge/thanatos_logic_bridge/src/ffi.rs.h)

add_library(thanatos_logic STATIC IMPORTED)
set_property(TARGET thanatos_logic PROPERTY IMPORTED_LOCATION ${RUST_LIBRARY_PATH})
add_dependencies(thanatos_logic rust_logic_lib)


# --- 5. 定义 thanatosd 可执行文件 ---
add_executable(thanatosd
    cpp/src/main.cpp
    cpp/src/grpc_server.cpp
    cpp/src/timer_manager.cpp
    cpp/src/kernel_interface.cpp
    cpp/src/shell_interface.cpp
)

target_link_libraries(thanatosd PRIVATE
    thanatos_proto
    thanatos_logic
    gRPC::grpc++
    protobuf::libprotobuf
    cxx           # Link against the cxx library from rust build
    LibEV::ev     # Link against libev
    -ldl          # Explicitly link dl for some gRPC dependencies
    -lpthread     # Explicitly link pthread
)

target_include_directories(thanatosd PRIVATE
    cpp/src
    # Include CXX generated headers
    ${RUST_BRIDGE_HEADER_PATH}/../.. # cxx.h
    ${RUST_BRIDGE_HEADER_PATH}/..   # ffi.rs.h
    # Include Protobuf generated headers
    ${PROTO_GEN_DIR}
    # Include libev headers
    ${LIBEV_INCLUDE_DIRS}
)
# Ensure proto code is generated before compiling C++
add_dependencies(thanatosd thanatos_proto)

# --- 6. 定义 (可选的) test_client 可执行文件 ---
add_executable(test_client
    cpp/src/test_client.cpp
)
target_link_libraries(test_client PRIVATE
    thanatos_proto
    gRPC::grpc++
    protobuf::libprotobuf
)
target_include_directories(test_client PRIVATE
    ${PROTO_GEN_DIR}
)
add_dependencies(test_client thanatos_proto)
```

---
### **`daemon/cpp` 目录**

#### **文件: `/Thanatos/daemon/cpp/src/grpc_server.h`**
```cpp
// 文件路径: /Thanatos/daemon/cpp/src/grpc_server.h
#ifndef THANATOS_GRPC_SERVER_H
#define THANATOS_GRPC_SERVER_H

#include <string>

// Starts the gRPC server. This function will block until the server is shut down.
void RunServer(const std::string& socket_path);

#endif //THANATOS_GRPC_SERVER_H
```

#### **文件: `/Thanatos/daemon/cpp/src/grpc_server.cpp`**
```cpp
// 文件路径: /Thanatos/daemon/cpp/src/grpc_server.cpp

#include "grpc_server.h"
#include <iostream>
#include <memory>
#include <thread>
#include <chrono>

#include <grpcpp/grpcpp.h>
#include <grpcpp/health_check_service_interface.h>

// Include generated headers
#include "thanatos.grpc.pb.h"
#include "thanatos_logic_bridge/src/ffi.rs.h"

// Forward declaration of the global Rust controller object
extern std::unique_ptr<LogicController> controller;

using grpc::Server;
using grpc::ServerBuilder;
using grpc::ServerContext;
using grpc::Status;
using grpc::ServerReader;
using grpc::ServerWriter;
using google::protobuf::Empty;

// --- Service Implementations ---

class AppControlServiceImpl final : public thanatos::ipc::AppControlService::Service {
public:
    Status SetAppConfig(ServerContext* context, const thanatos::ipc::AppConfig* request, Empty* response) override {
        std::cout << "[C++ gRPC] SetAppConfig for " << request->package_name() << std::endl;
        
        ffi::CxxAppConfig cxx_config;
        cxx_config.package_name = request->package_name();
        cxx_config.policy = static_cast<int32_t>(request->policy());
        cxx_config.freeze_mode = static_cast<int32_t>(request->freeze_mode());
        cxx_config.oom_priority = static_cast<int32_t>(request->oom_priority());
        cxx_config.network_policy = static_cast<int32_t>(request->network_policy());
        cxx_config.allow_wakeup_for_push = request->allow_wakeup_for_push();
        cxx_config.allow_autostart = request->allow_autostart();
        
        rust_set_app_config(*controller, cxx_config);
        
        return Status::OK;
    }

    Status SetLaunchRule(ServerContext* context, const thanatos::ipc::LaunchRule* request, Empty* response) override {
        ffi::CxxLaunchRule cxx_rule;
        cxx_rule.source_package = request->source_package();
        cxx_rule.target_package = request->target_package();
        cxx_rule.allowed = request->allowed();
        
        rust_set_launch_rule(*controller, cxx_rule);
        
        return Status::OK;
    }
};

class SystemServiceImpl final : public thanatos::ipc::SystemService::Service {
public:
    Status PushFrameworkEvents(ServerContext* context, ServerReader<thanatos::ipc::FrameworkEvent>* reader) override {
        thanatos::ipc::FrameworkEvent event;
        while (reader->Read(&event)) {
            if (context->IsCancelled()) break;

            ffi::CxxFrameworkEvent cxx_event;
            cxx_event.event_type = static_cast<int32_t>(event.event_type());
            cxx_event.source_package = event.source_package();
            cxx_event.target_package = event.target_package();
            cxx_event.timestamp = event.timestamp();
            
            rust_handle_framework_event(*controller, cxx_event);
        }
        return Status::OK;
    }

    Status RequestTemporaryUnfreeze(ServerContext* context, const thanatos::ipc::TempUnfreezeRequest* request, Empty* response) override {
        rust_request_temporary_unfreeze(
            *controller,
            request->package_name(),
            static_cast<int32_t>(request->reason()),
            request->duration_ms()
        );
        return Status::OK;
    }

    Status ShouldAllowLaunch(ServerContext* context, const thanatos::ipc::LaunchRule* request, thanatos::ipc::LaunchRule* response) override {
        ffi::CxxLaunchRule cxx_request_rule;
        cxx_request_rule.source_package = request->source_package();
        cxx_request_rule.target_package = request->target_package();
        
        auto cxx_response_rule = rust_should_allow_launch(*controller, cxx_request_rule);

        response->set_source_package(cxx_response_rule.source_package);
        response->set_target_package(cxx_response_rule.target_package);
        response->set_allowed(cxx_response_rule.allowed);

        return Status::OK;
    }
};

class DashboardServiceImpl final : public thanatos::ipc::DashboardService::Service {
public:
    Status StreamRuntimeStats(ServerContext* context, const Empty* request, ServerWriter<thanatos::ipc::RuntimeStats>* writer) override {
        std::cout << "[C++ gRPC] Client subscribed to StreamRuntimeStats." << std::endl;
        
        while (!context->IsCancelled()) {
            auto rust_stats = rust_get_runtime_stats(*controller);
            
            thanatos::ipc::RuntimeStats stats;
            stats.set_total_mem_kb(rust_stats.total_mem_kb);
            stats.set_avail_mem_kb(rust_stats.avail_mem_kb);
            stats.set_frozen_app_count(rust_stats.frozen_app_count);
            stats.set_cpu_usage_percent(rust_stats.cpu_usage_percent);
            stats.set_network_speed_bps(rust_stats.network_speed_bps);

            if (!writer->Write(stats)) {
                break; // Client disconnected
            }

            // Sleep for 1 second
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }

        std::cout << "[C++ gRPC] Client disconnected from StreamRuntimeStats." << std::endl;
        return Status::OK;
    }
    
    Status GetRecentEvents(ServerContext* context, const Empty* request, ServerWriter<thanatos::ipc::EventLog>* writer) override {
        auto events = rust_get_recent_events(*controller, 50); // Get last 50 events
        for (const auto& event : events) {
            if (context->IsCancelled()) break;
            
            thanatos::ipc::EventLog log;
            log.set_timestamp(event.timestamp);
            log.set_package_name(event.package_name);
            log.set_event_description(event.description);
            
            if (!writer->Write(log)) {
                break; // Client disconnected
            }
        }
        return Status::OK;
    }
};

// --- Server Main Function ---

void RunServer(const std::string& socket_path) {
    std::string server_address = "unix:" + socket_path;
    
    AppControlServiceImpl app_service;
    SystemServiceImpl system_service;
    DashboardServiceImpl dashboard_service;

    grpc::EnableDefaultHealthCheckService(true);
    ServerBuilder builder;

    builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());
    
    builder.RegisterService(&app_service);
    builder.RegisterService(&system_service);
    builder.RegisterService(&dashboard_service);

    std::unique_ptr<Server> server(builder.BuildAndStart());
    std::cout << "[C++ gRPC] Server listening on " << server_address << std::endl;

    // This will block the calling thread (which is intended for the gRPC thread)
    server->Wait();
}

```

#### **文件: `/Thanatos/daemon/cpp/src/kernel_interface.h`**
```cpp
// 文件路径: /Thanatos/daemon/cpp/src/kernel_interface.h
#ifndef THANATOS_KERNEL_INTERFACE_H
#define THANATOS_KERNEL_INTERFACE_H

#include <cstdint>
#include <string>

void set_oom_score_adj(int pid, int score);
int64_t get_available_memory_kb();
int64_t get_total_memory_kb();
float get_cpu_usage_percent(); // Note: This is a simplified implementation

#endif //THANATOS_KERNEL_INTERFACE_H
```

#### **文件: `/Thanatos/daemon/cpp/src/kernel_interface.cpp`**
```cpp
// 文件路径: /Thanatos/daemon/cpp/src/kernel_interface.cpp
#include "kernel_interface.h"
#include <fstream>
#include <iostream>
#include <string>
#include <vector>
#include <numeric>
#include <unistd.h>

void set_oom_score_adj(int pid, int score) {
    std::string path = "/proc/" + std::to_string(pid) + "/oom_score_adj";
    std::ofstream file(path);
    if (file.is_open()) {
        file << score;
        file.close();
    } else {
        // This can fail if the process is already gone, which is not a critical error.
        // std::cerr << "Failed to open " << path << std::endl;
    }
}

long long parse_mem_value(const std::string& line) {
    long long val = 0;
    sscanf(line.c_str(), "%*s %lld kB", &val);
    return val;
}

int64_t get_available_memory_kb() {
    std::ifstream meminfo("/proc/meminfo");
    std::string line;
    while (std::getline(meminfo, line)) {
        if (line.rfind("MemAvailable:", 0) == 0) {
            return parse_mem_value(line);
        }
    }
    return 0; // Fallback
}

int64_t get_total_memory_kb() {
    std::ifstream meminfo("/proc/meminfo");
    std::string line;
    while (std::getline(meminfo, line)) {
        if (line.rfind("MemTotal:", 0) == 0) {
            return parse_mem_value(line);
        }
    }
    return 0; // Fallback
}


// --- Simplified CPU Usage ---
struct CpuTimes {
    long long user = 0, nice = 0, system = 0, idle = 0, iowait = 0, irq = 0, softirq = 0;
};

CpuTimes read_cpu_times() {
    std::ifstream stat_file("/proc/stat");
    std::string line;
    CpuTimes times;
    if (std::getline(stat_file, line) && line.rfind("cpu", 0) == 0) {
        sscanf(line.c_str(), "cpu %lld %lld %lld %lld %lld %lld %lld",
               &times.user, &times.nice, &times.system, &times.idle,
               &times.iowait, &times.irq, &times.softirq);
    }
    return times;
}

float get_cpu_usage_percent() {
    static CpuTimes prev_times = {0,0,0,0,0,0,0};
    
    CpuTimes current_times = read_cpu_times();

    auto prev_idle = prev_times.idle + prev_times.iowait;
    auto current_idle = current_times.idle + current_times.iowait;

    auto prev_non_idle = prev_times.user + prev_times.nice + prev_times.system + prev_times.irq + prev_times.softirq;
    auto current_non_idle = current_times.user + current_times.nice + current_times.system + current_times.irq + current_times.softirq;

    auto prev_total = prev_idle + prev_non_idle;
    auto current_total = current_idle + current_non_idle;

    auto total_diff = current_total - prev_total;
    auto idle_diff = current_idle - prev_idle;

    prev_times = current_times;

    if (total_diff == 0) return 0.0f;

    return (float)(total_diff - idle_diff) * 100.0f / total_diff;
}
```

#### **文件: `/Thanatos/daemon/cpp/src/main.cpp`**
```cpp
// 文件路径: /Thanatos/daemon/cpp/src/main.cpp
#include <iostream>
#include <thread>
#include <memory>
#include <unistd.h>
#include <ev.h>

#include "grpc_server.h"
#include "timer_manager.h"
#include "thanatos_logic_bridge/src/ffi.rs.h"

// --- Global Variables ---
// The one and only instance of our Rust logic controller.
std::unique_ptr<LogicController> controller;
// The default libev event loop.
struct ev_loop *main_loop;

// --- Constants ---
const char* SOCKET_PATH = "/data/local/tmp/thanatosd.sock";
const char* DB_PATH = "/data/adb/modules/thanatos-core/thanatos.db";

// --- libev Callbacks ---
static ev_timer memory_check_watcher;

static void memory_check_callback(EV_P_ ev_timer *w, int revents) {
    if (!controller) return;
    rust_perform_memory_cleanup(*controller);
}

// --- Main Entry Point ---
int main(int argc, char** argv) {
    std::cout << "[C++ main] Starting thanatosd daemon..." << std::endl;

    // 1. Initialize Rust Logic Controller
    controller = rust_init_controller(DB_PATH);
    if (!controller) {
        std::cerr << "[C++ main] CRITICAL: Failed to initialize Rust controller. Exiting." << std::endl;
        return 1;
    }
    std::cout << "[C++ main] Rust controller initialized." << std::endl;

    // 2. Initialize libev event loop
    main_loop = EV_DEFAULT;
    if (!main_loop) {
        std::cerr << "[C++ main] CRITICAL: Could not initialize libev. Exiting." << std::endl;
        return 1;
    }

    // 3. Initialize Timer Manager
    init_timer_manager(main_loop);
    std::cout << "[C++ main] Timer manager initialized." << std::endl;

    // 4. Start the gRPC server in a separate thread
    // This is crucial because server->Wait() is a blocking call.
    std::thread grpc_thread(RunServer, std::string(SOCKET_PATH));
    grpc_thread.detach(); // Let the gRPC server run independently.
    std::cout << "[C++ main] gRPC server thread launched." << std::endl;
    
    // 5. Setup periodic tasks with libev
    // Setup memory cleanup task (e.g., every 60 seconds)
    ev_timer_init(&memory_check_watcher, memory_check_callback, 60.0, 60.0);
    ev_timer_start(main_loop, &memory_check_watcher);
    std::cout << "[C++ main] Periodic memory checker scheduled." << std::endl;

    // 6. Start the main event loop
    // This will block and process events (like timers firing) until ev_break is called.
    std::cout << "[C++ main] Starting main event loop. Daemon is now fully operational." << std::endl;
    ev_run(main_loop, 0);

    // This part of the code is unlikely to be reached unless the loop is explicitly broken.
    std::cout << "[C++ main] Event loop finished. Shutting down." << std::endl;
    
    return 0;
}
```

#### **文件: `/Thanatos/daemon/cpp/src/shell_interface.h`**

```cpp
// 文件路径: /Thanatos/daemon/cpp/src/shell_interface.h
#ifndef THANATOS_SHELL_INTERFACE_H
#define THANATOS_SHELL_INTERFACE_H

#include <string>

// Executes a shell command and returns its standard output.
std::string execute_shell_command(const std::string& command);

#endif //THANATOS_SHELL_INTERFACE_H
```

#### **文件: `/Thanatos/daemon/cpp/src/shell_interface.cpp`**
```cpp
// 文件路径: /Thanatos/daemon/cpp/src/shell_interface.cpp
#include "shell_interface.h"
#include <cstdio>
#include <iostream>
#include <memory>
#include <stdexcept>
#include <array>

std::string execute_shell_command(const std::string& command) {
    std::array<char, 256> buffer;
    std::string result;
    
    // Using popen to execute a command and read its output.
    // The '2>&1' part redirects stderr to stdout, so we capture both.
    std::string full_command = command + " 2>&1";
    
    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(full_command.c_str(), "r"), pclose);
    
    if (!pipe) {
        std::cerr << "popen() failed for command: " << command << std::endl;
        return "ERROR: popen() failed";
    }
    
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        result += buffer.data();
    }
    
    return result;
}
```

#### **文件: `/Thanatos/daemon/cpp/src/timer_manager.h`**
```cpp
// 文件路径: /Thanatos/daemon/cpp/src/timer_manager.h
#ifndef THANATOS_TIMER_MANAGER_H
#define THANATOS_TIMER_MANAGER_H

#include <cstdint>

// Forward declaration of libev's loop struct
struct ev_loop;

// Initializes the timer manager with the main event loop.
void init_timer_manager(struct ev_loop* loop);

// Creates a one-shot timer that fires after a specified duration.
// Returns a unique timer ID.
int64_t create_oneshot_timer(int32_t duration_ms);

// Cancels a timer using its ID.
void cancel_timer(int64_t timer_id);

#endif //THANATOS_TIMER_MANAGER_H
```

#### **文件: `/Thanatos/daemon/cpp/src/timer_manager.cpp`**
```cpp
// 文件路径: /Thanatos/daemon/cpp/src/timer_manager.cpp
#include "timer_manager.h"
#include <ev.h>
#include <map>
#include <mutex>
#include <iostream>

#include "thanatos_logic_bridge/src/ffi.rs.h"

// Forward declaration of the global Rust controller
extern std::unique_ptr<LogicController> controller;

// --- Static variables for timer management ---
static struct ev_loop* loop_ = nullptr;
static std::map<int64_t, ev_timer*> active_timers;
static std::mutex timers_mutex;
static int64_t next_timer_id = 1;

// The callback function executed by libev when a timer fires.
static void timer_callback(EV_P_ ev_timer *w, int revents) {
    // Retrieve the timer ID stored in the watcher's data field.
    int64_t timer_id = reinterpret_cast<int64_t>(w->data);
    
    // Notify the Rust layer that the timer has fired.
    if (controller) {
        rust_on_timer_fired(*controller, timer_id);
    }

    // Clean up resources for this one-shot timer.
    std::lock_guard<std::mutex> lock(timers_mutex);
    active_timers.erase(timer_id);
    ev_timer_stop(EV_A_ w);
    delete w; // Free the watcher memory.
}

void init_timer_manager(struct ev_loop* loop) {
    loop_ = loop;
}

int64_t create_oneshot_timer(int32_t duration_ms) {
    if (!loop_) {
        std::cerr << "[C++ Timer] Error: Timer manager not initialized!" << std::endl;
        return 0;
    }
    
    std::lock_guard<std::mutex> lock(timers_mutex);
    
    int64_t timer_id = next_timer_id++;
    ev_timer* timer_watcher = new ev_timer();
    timer_watcher->data = reinterpret_cast<void*>(timer_id);
    
    double duration_sec = static_cast<double>(duration_ms) / 1000.0;
    
    ev_timer_init(timer_watcher, timer_callback, duration_sec, 0.);
    ev_timer_start(loop_, timer_watcher);

    active_timers[timer_id] = timer_watcher;
    std::cout << "[C++ Timer] Created timer with ID " << timer_id << " for " << duration_ms << "ms" << std::endl;
    
    return timer_id;
}

void cancel_timer(int64_t timer_id) {
    std::lock_guard<std::mutex> lock(timers_mutex);
    auto it = active_timers.find(timer_id);
    if (it != active_timers.end()) {
        ev_timer_stop(loop_, it->second);
        delete it->second;
        active_timers.erase(it);
        std::cout << "[C++ Timer] Canceled timer with ID " << timer_id << std::endl;
    }
}

// --- Implementation of functions callable by Rust via CXX ---

// These functions are the C++ side of the FFI bridge defined in `ffi.rs`.
// They simply delegate to the internal timer management functions.
int64_t cpp_create_oneshot_timer(int32_t duration_ms) {
    return create_oneshot_timer(duration_ms);
}

void cpp_cancel_timer(int64_t timer_id) {
    cancel_timer(timer_id);
}

// We need to declare and implement all C++ functions called by Rust.
// We'll put them all here for simplicity.
#include "kernel_interface.h"
#include "shell_interface.h"

void cpp_set_oom_score_adj(int32_t pid, int32_t score) {
    set_oom_score_adj(pid, score);
}

int64_t cpp_get_available_memory_kb() {
    return get_available_memory_kb();
}

int64_t cpp_get_total_memory_kb() {
    return get_total_memory_kb();
}

float cpp_get_cpu_usage_percent() {
    return get_cpu_usage_percent();
}

rust::String cpp_execute_shell(rust::Str command) {
    return execute_shell_command(std::string(command));
}
```

#### **文件: `/Thanatos/daemon/cpp/src/test_client.cpp`**
```cpp
// 文件路径: /Thanatos/daemon/cpp/src/test_client.cpp
// This is an optional utility for testing the daemon on the build server
// without needing a full Android App.

#include <iostream>
#include <memory>
#include <string>
#include <grpcpp/grpcpp.h>

#include "thanatos.grpc.pb.h"

using grpc::Channel;
using grpc::ClientContext;
using grpc::Status;
using grpc::ClientReader;

using thanatos::ipc::DashboardService;
using thanatos::ipc::RuntimeStats;
using google::protobuf::Empty;

// Use /tmp for testing on a standard Linux host.
const char* SOCKET_PATH = "/tmp/thanatosd.sock";

class DashboardClient {
public:
    DashboardClient(std::shared_ptr<Channel> channel)
        : stub_(DashboardService::NewStub(channel)) {}

    void GetRuntimeStatsStream() {
        ClientContext context;
        Empty request;
        RuntimeStats stats;

        std::unique_ptr<ClientReader<RuntimeStats>> reader(
            stub_->StreamRuntimeStats(&context, request));

        std::cout << "Client: Calling StreamRuntimeStats..." << std::endl;
        
        while (reader->Read(&stats)) {
            std::cout << "--------------------------------" << std::endl;
            std::cout << "Received Stats at " << std::time(nullptr) << ":" << std::endl;
            std::cout << "  Total Memory: " << stats.total_mem_kb() / 1024 << " MB" << std::endl;
            std::cout << "  Avail Memory: " << stats.avail_mem_kb() / 1024 << " MB" << std::endl;
            std::cout << "  Frozen Apps:  " << stats.frozen_app_count() << std::endl;
            std::cout << "  CPU Usage:    " << stats.cpu_usage_percent() << "%" << std::endl;
            std::cout << "  Net Speed:    " << stats.network_speed_bps() / 1000 << " Kbps" << std::endl;
            std::cout << "--------------------------------" << std::endl;
        }

        Status status = reader->Finish();
        if (status.ok()) {
            std::cout << "Client: Stream finished successfully." << std::endl;
        } else {
            std::cout << "Client: RPC failed. " << status.error_code() << ": " << status.error_message()
                      << std::endl;
        }
    }

private:
    std::unique_ptr<DashboardService::Stub> stub_;
};

int main(int argc, char** argv) {
    std::string server_address = "unix:" + std::string(SOCKET_PATH);
    auto channel = grpc::CreateChannel(server_address, grpc::InsecureChannelCredentials());
    DashboardClient client(channel);

    client.GetRuntimeStatsStream();

    return 0;
}
```

---


### **`daemon/rust` 目录**

#### **文件: `/Thanatos/daemon/rust/Cargo.toml`**
```toml
# 文件路径: /Thanatos/daemon/rust/Cargo.toml

[package]
name = "thanatos_logic"
version = "2.0.0"
edition = "2021"

[lib]
crate-type = ["staticlib"] # We compile to a static library for C++ to link against.

[dependencies]
# FFI bridge to C++
cxx = "1.0"

# Database
rusqlite = { version = "0.31.0", features = ["bundled"] }

# Logging
log = "0.4"
env_logger = "0.11"

# High-performance concurrent HashMap
dashmap = "5.5.3"

# Direct libc calls for sending signals
libc = "0.2"

# Protobuf/gRPC types
prost = "0.12"
tonic = "0.11"

[build-dependencies]
cxx-build = "1.0"
# For generating Rust gRPC/Protobuf code from .proto files
tonic-build = { version = "0.11", features = ["prost"] }
```

#### **文件: `/Thanatos/daemon/rust/build.rs`**
```rust
// 文件路径: /Thanatos/daemon/rust/build.rs

fn main() {
    // 1. Compile Protobuf/gRPC definitions for Rust.
    // This generates Rust types and service traits from the .proto file.
    let proto_path = "../../ipc/proto/thanatos.proto";
    println!("cargo:rerun-if-changed={}", proto_path);
    tonic_build::configure()
        .build_server(true)  // We need server traits for type definitions.
        .build_client(false) // We don't implement a Rust gRPC client in the daemon.
        .out_dir("src/grpc_generated") // Output to a dedicated directory.
        .compile(&[proto_path], &["../../ipc/proto"])
        .unwrap_or_else(|e| panic!("Failed to compile protos: {}", e));

    // 2. Build the CXX FFI bridge.
    // This generates the C++ header and the Rust-side FFI implementation.
    cxx_build::bridge("src/ffi.rs") // The file with the #[cxx::bridge] module.
        // List all Rust files that contain `extern "Rust"` function implementations.
        .file("src/lib.rs")
        .file("src/logic_controller.rs")
        .file("src/config_manager.rs")
        .file("src/event_logger.rs")
        .file("src/execution_manager.rs")
        .file("src/ml_collector.rs")
        .flag_if_supported("-std=c++17")
        .compile("thanatos_logic_bridge");

    // Tell Cargo when to rerun this build script.
    println!("cargo:rerun-if-changed=src/lib.rs");
    println!("cargo:rerun-if-changed=src/ffi.rs");
    println!("cargo:rerun-if-changed=src/logic_controller.rs");
    println!("cargo:rerun-if-changed=src/config_manager.rs");
    println!("cargo:rerun-if-changed=src/event_logger.rs");
    println!("cargo:rerun-if-changed=src/execution_manager.rs");
    println!("cargo:rerun-if-changed=src/ml_collector.rs");
}
```

#### **文件: `/Thanatos/daemon/rust/src/config_manager.rs`**
```rust
// 文件路径: /Thanatos/daemon/rust/src/config_manager.rs
use crate::grpc_generated::thanatos::ipc::{AppConfig, LaunchRule};
use rusqlite::{Connection, Result};
use std::sync::{Arc, Mutex};

pub struct ConfigManager {
    conn: Arc<Mutex<Connection>>,
}

impl ConfigManager {
    pub fn new(db_path: &str) -> Result<Self> {
        let conn = Connection::open(db_path)?;
        let config_manager = ConfigManager {
            conn: Arc::new(Mutex::new(conn)),
        };
        config_manager.init_db()?;
        Ok(config_manager)
    }

    fn init_db(&self) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        // App configurations table
        conn.execute(
            "CREATE TABLE IF NOT EXISTS app_configs (
                package_name TEXT PRIMARY KEY,
                policy INTEGER NOT NULL,
                freeze_mode INTEGER NOT NULL,
                oom_priority INTEGER NOT NULL,
                network_policy INTEGER NOT NULL,
                allow_wakeup_for_push BOOLEAN NOT NULL,
                allow_autostart BOOLEAN NOT NULL
            )",
            [],
        )?;
        // Launch rules table
        conn.execute(
            "CREATE TABLE IF NOT EXISTS launch_rules (
                source_package TEXT NOT NULL,
                target_package TEXT NOT NULL,
                allowed BOOLEAN NOT NULL,
                PRIMARY KEY (source_package, target_package)
            )",
            [],
        )?;
        Ok(())
    }

    pub fn set_app_config(&self, config: &AppConfig) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute(
            "INSERT OR REPLACE INTO app_configs (
                package_name, policy, freeze_mode, oom_priority, network_policy,
                allow_wakeup_for_push, allow_autostart
            ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)",
            rusqlite::params![
                config.package_name,
                config.policy,
                config.freeze_mode,
                config.oom_priority,
                config.network_policy,
                config.allow_wakeup_for_push,
                config.allow_autostart,
            ],
        )?;
        Ok(())
    }

    pub fn get_app_config(&self, package_name: &str) -> Result<Option<AppConfig>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare("SELECT * FROM app_configs WHERE package_name = ?1")?;
        let mut rows = stmt.query_map([package_name], |row| {
            Ok(AppConfig {
                package_name: row.get(0)?,
                policy: row.get(1)?,
                freeze_mode: row.get(2)?,
                oom_priority: row.get(3)?,
                network_policy: row.get(4)?,
                allow_wakeup_for_push: row.get(5)?,
                allow_autostart: row.get(6)?,
            })
        })?;

        rows.next().transpose().map_err(|e| e.into())
    }

    pub fn set_launch_rule(&self, rule: &LaunchRule) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute(
            "INSERT OR REPLACE INTO launch_rules (source_package, target_package, allowed) VALUES (?1, ?2, ?3)",
            rusqlite::params![rule.source_package, rule.target_package, rule.allowed],
        )?;
        Ok(())
    }
    
    pub fn get_launch_rule(&self, source: &str, target: &str) -> Result<Option<bool>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare("SELECT allowed FROM launch_rules WHERE source_package = ?1 AND target_package = ?2")?;
        stmt.query_row([source, target], |row| row.get(0)).map(Some).or_else(|e| {
            if e == rusqlite::Error::QueryReturnedNoRows {
                Ok(None)
            } else {
                Err(e)
            }
        })
    }
}
```

#### **文件: `/Thanatos/daemon/rust/src/event_logger.rs`**
```rust
// 文件路径: /Thanatos/daemon/rust/src/event_logger.rs
use crate::grpc_generated::thanatos::ipc::EventLog;
use rusqlite::{Connection, Result};
use std::sync::{Arc, Mutex};

pub struct EventLogger {
    conn: Arc<Mutex<Connection>>,
}

impl EventLogger {
    pub fn new(conn: Arc<Mutex<Connection>>) -> Self {
        Self { conn }
    }

    pub fn init_db(&self) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute(
            "CREATE TABLE IF NOT EXISTS event_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp INTEGER NOT NULL,
                package_name TEXT,
                description TEXT NOT NULL
            )",
            [],
        )?;
        Ok(())
    }

    pub fn log(&self, pkg_name: Option<&str>, description: &str) {
        let conn_guard = self.conn.lock().unwrap();
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as i64;

        if let Err(e) = conn_guard.execute(
            "INSERT INTO event_log (timestamp, package_name, description) VALUES (?1, ?2, ?3)",
            rusqlite::params![timestamp, pkg_name, description],
        ) {
            log::error!("Failed to write event log: {}", e);
        }
    }
    
    pub fn get_recent_events(&self, limit: u32) -> Result<Vec<EventLog>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare("SELECT timestamp, package_name, description FROM event_log ORDER BY id DESC LIMIT ?1")?;
        let rows = stmt.query_map([limit], |row| {
            Ok(EventLog {
                timestamp: row.get(0)?,
                package_name: row.get::<_, Option<String>>(1)?.unwrap_or_default(),
                event_description: row.get(2)?,
            })
        })?;
        
        rows.collect::<Result<Vec<EventLog>>>()
    }
}
```

#### **文件: `/Thanatos/daemon/rust/src/execution_manager.rs`**
```rust
// 文件路径: /Thanatos/daemon/rust/src/execution_manager.rs
use crate::grpc_generated::thanatos::ipc::FreezeMode;

pub fn freeze_app(pid: i32, mode: FreezeMode) {
    if pid <= 0 {
        log::warn!("Invalid PID {} for freezing", pid);
        return;
    }
    log::info!("Executing freeze for PID: {} with mode {:?}", pid, mode);
    unsafe {
        match mode {
            FreezeMode::ModeSigstop => {
                libc::kill(pid, libc::SIGSTOP);
            }
            FreezeMode::ModeKill => {
                libc::kill(pid, libc::SIGKILL);
            }
            FreezeMode::ModeHibernate => {
                // This requires executing a shell command, which is handled in C++
                log::warn!("Hibernate mode not fully implemented in Rust execution manager. Use shell interface.");
                libc::kill(pid, libc::SIGSTOP); // Fallback
            }
            FreezeMode::ModeUnspecified => {
                log::warn!("Unspecified freeze mode for PID {}, defaulting to SIGSTOP", pid);
                libc::kill(pid, libc::SIGSTOP);
            }
        }
    }
}

pub fn unfreeze_app(pid: i32) {
    if pid <= 0 {
        log::warn!("Invalid PID {} for unfreezing", pid);
        return;
    }
    log::info!("Executing unfreeze for PID: {}", pid);
    unsafe {
        libc::kill(pid, libc::SIGCONT);
    }
}
```

#### **文件: `/Thanatos/daemon/rust/src/ml_collector.rs`**
```rust
// 文件路径: /Thanatos/daemon/rust/src/ml_collector.rs
use rusqlite::{Connection, Result};
use std::sync::{Arc, Mutex};

pub struct MLDataCollector {
    conn: Arc<Mutex<Connection>>,
}

impl MLDataCollector {
    pub fn new(conn: Arc<Mutex<Connection>>) -> Self {
        Self { conn }
    }
    
    pub fn init_db(&self) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute(
            "CREATE TABLE IF NOT EXISTS ai_training_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp INTEGER NOT NULL,
                context_pkg TEXT,      -- The app that was in foreground
                target_pkg TEXT NOT NULL,  -- The app the user interacted with
                event_type TEXT NOT NULL,  -- e.g., 'USER_LAUNCH_AFTER_FREEZE'
                label INTEGER NOT NULL     -- e.g., 1 for positive, 0 for negative
            )",
            [],
        )?;
        Ok(())
    }
    
    pub fn log_training_data(&self, context_pkg: Option<&str>, target_pkg: &str, event_type: &str, label: i32) {
        let conn = self.conn.lock().unwrap();
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as i64;
            
        if let Err(e) = conn.execute(
            "INSERT INTO ai_training_data (timestamp, context_pkg, target_pkg, event_type, label) VALUES (?1, ?2, ?3, ?4, ?5)",
            rusqlite::params![timestamp, context_pkg, target_pkg, event_type, label],
        ) {
            log::error!("Failed to log AI training data: {}", e);
        } else {
            log::info!("Logged AI training data for event: {}", event_type);
        }
    }
}
```

#### **文件: `/Thanatos/daemon/rust/src/ffi.rs`**
```rust
// 文件路径: /Thanatos/daemon/rust/src/ffi.rs

#[cxx::bridge(namespace = "thanatos")]
pub mod ffi {
    // --- Structs for safe data transfer between C++ and Rust ---
    #[derive(Default)]
    struct CxxAppConfig {
        package_name: String,
        policy: i32,
        freeze_mode: i32,
        oom_priority: i32,
        network_policy: i32,
        allow_wakeup_for_push: bool,
        allow_autostart: bool,
    }

    #[derive(Default)]
    struct CxxLaunchRule {
        source_package: String,
        target_package: String,
        allowed: bool,
    }
    
    #[derive(Default)]
    struct CxxFrameworkEvent {
        event_type: i32,
        source_package: String,
        target_package: String,
        timestamp: i64,
    }

    #[derive(Default)]
    struct RustRuntimeStats {
        total_mem_kb: i64,
        avail_mem_kb: i64,
        frozen_app_count: i32,
        cpu_usage_percent: f32,
        network_speed_bps: i64,
    }
    
    #[derive(Default)]
    struct CxxEventLog {
        timestamp: i64,
        package_name: String,
        description: String,
    }

    // --- Rust functions exposed to C++ ---
    extern "Rust" {
        type LogicController;

        // Lifecycle
        fn rust_init_controller(db_path: &str) -> UniquePtr<LogicController>;

        // App Control
        fn rust_set_app_config(controller: &LogicController, config: CxxAppConfig);
        fn rust_set_launch_rule(controller: &LogicController, rule: CxxLaunchRule);

        // System Events & Decisions
        fn rust_handle_framework_event(controller: &LogicController, event: CxxFrameworkEvent);
        fn rust_request_temporary_unfreeze(controller: &LogicController, package_name: &str, reason: i32, duration_ms: i32);
        fn rust_should_allow_launch(controller: &LogicController, rule: CxxLaunchRule) -> CxxLaunchRule;
        fn rust_on_timer_fired(controller: &LogicController, timer_id: i64);
        fn rust_perform_memory_cleanup(controller: &LogicController);

        // Dashboard
        fn rust_get_runtime_stats(controller: &LogicController) -> RustRuntimeStats;
        fn rust_get_recent_events(controller: &LogicController, limit: u32) -> Vec<CxxEventLog>;
    }

    // --- C++ functions callable from Rust ---
    unsafe extern "C++" {
        // Timers
        fn cpp_create_oneshot_timer(duration_ms: i32) -> i64;
        fn cpp_cancel_timer(timer_id: i64);

        // Kernel Interface
        fn cpp_set_oom_score_adj(pid: i32, score: i32);
        fn cpp_get_available_memory_kb() -> i64;
        fn cpp_get_total_memory_kb() -> i64;
        fn cpp_get_cpu_usage_percent() -> f32;
        
        // Shell
        fn cpp_execute_shell(command: &str) -> String;
    }
}
```

#### **文件: `/Thanatos/daemon/rust/src/logic_controller.rs`**
```rust
// 文件路径: /Thanatos/daemon/rust/src/logic_controller.rs

use crate::config_manager::ConfigManager;
use crate::event_logger::EventLogger;
use crate::execution_manager::{freeze_app, unfreeze_app};
use crate::ffi;
use crate::grpc_generated::thanatos::ipc::{self as grpc_ipc};
use crate::ml_collector::MLDataCollector;

use dashmap::DashMap;
use std::collections::VecDeque;
use std::sync::{Arc, Mutex};

#[derive(Debug, Clone)]
pub enum AppState {
    Foreground(i32), // pid
    Background(i32), // pid
    Frozen(i32),     // pid
    TemporarilyUnfrozen { pid: i32, refreeze_timer_id: i64 },
}

pub struct LogicController {
    config_manager: Arc<ConfigManager>,
    event_logger: Arc<EventLogger>,
    ml_collector: Arc<MLDataCollector>,
    runtime_states: Arc<DashMap<String, AppState>>,
    smart_standby_timer_id: Arc<Mutex<Option<i64>>>,
    background_lru: Arc<Mutex<VecDeque<String>>>,
    foreground_package: Arc<Mutex<String>>,
}

impl LogicController {
    pub fn new(
        config_manager: Arc<ConfigManager>,
        event_logger: Arc<EventLogger>,
        ml_collector: Arc<MLDataCollector>,
    ) -> Self {
        Self {
            config_manager,
            event_logger,
            ml_collector,
            runtime_states: Arc::new(DashMap::new()),
            smart_standby_timer_id: Arc::new(Mutex::new(None)),
            background_lru: Arc::new(Mutex::new(VecDeque::with_capacity(100))),
            foreground_package: Arc::new(Mutex::new(String::new())),
        }
    }

    // --- Public API called from FFI ---

    pub fn set_app_config(&self, config: grpc_ipc::AppConfig) {
        let pkg = config.package_name.clone();
        if let Err(e) = self.config_manager.set_app_config(&config) {
            self.event_logger.log(Some(&pkg), &format!("Error setting config: {}", e));
        } else {
            self.event_logger.log(Some(&pkg), "Configuration updated");
        }
    }

    pub fn set_launch_rule(&self, rule: grpc_ipc::LaunchRule) {
        if let Err(e) = self.config_manager.set_launch_rule(&rule) {
            log::error!("Failed to set launch rule: {}", e);
        }
    }

    pub fn handle_framework_event(&self, event: grpc_ipc::FrameworkEvent) {
        match event.event_type() {
            grpc_ipc::framework_event::EventType::AppForeground => self.handle_app_state_change(event, true),
            grpc_ipc::framework_event::EventType::AppBackground => self.handle_app_state_change(event, false),
            grpc_ipc::framework_event::EventType::ScreenOn => self.handle_screen_on(),
            grpc_ipc::framework_event::EventType::ScreenOff => self.handle_screen_off(),
            _ => {}
        }
    }
    
    pub fn request_temporary_unfreeze(&self, package_name: &str, reason: grpc_ipc::UnfreezeReason, duration_ms: i32) {
        if let Some(mut state_entry) = self.runtime_states.get_mut(package_name) {
            if let AppState::Frozen(pid) = *state_entry {
                log::info!("Unfreezing '{}' (PID: {}) temporarily.", package_name, pid);
                unfreeze_app(pid);
                self.event_logger.log(Some(package_name), &format!("Temporarily unfrozen for {:?}", reason));

                let timer_id = unsafe { ffi::cpp_create_oneshot_timer(duration_ms) };
                *state_entry = AppState::TemporarilyUnfrozen { pid, refreeze_timer_id: timer_id };
            }
        }
    }

    pub fn should_allow_launch(&self, rule: &grpc_ipc::LaunchRule) -> grpc_ipc::LaunchRule {
        let mut result_rule = rule.clone();
        match self.config_manager.get_launch_rule(&rule.source_package, &rule.target_package) {
            Ok(Some(allowed)) => result_rule.allowed = allowed,
            Ok(None) => result_rule.allowed = true, // Default allow
            Err(e) => {
                log::error!("DB error on get_launch_rule: {}", e);
                result_rule.allowed = true; // Fail-safe
            }
        }
        if !result_rule.allowed {
            self.event_logger.log(Some(&rule.source_package), &format!("Blocked launch towards {}", rule.target_package));
        }
        result_rule
    }

    pub fn on_timer_fired(&self, timer_id: i64) {
        if self.handle_standby_timer(timer_id) { return; }
        self.handle_refreeze_timer(timer_id);
    }
    
    pub fn perform_memory_cleanup(&self) {
        let avail_mem_kb = unsafe { ffi::cpp_get_available_memory_kb() };
        let threshold_kb: i64 = 500 * 1024; // 500MB, should be configurable

        if avail_mem_kb < threshold_kb {
            log::warn!("Low memory detected ({avail_mem_kb}KB < {threshold_kb}KB). Starting cleanup.");
            self.event_logger.log(None, "Low memory detected, starting cleanup.");
            
            let lru = self.background_lru.lock().unwrap();
            for pkg_name in lru.iter().rev().take(3) { // Clean up to 3 apps
                if let Some(state) = self.runtime_states.get(pkg_name) {
                    if let AppState::Background(pid) | AppState::Frozen(pid) = *state.value() {
                        // TODO: Check config for OOM_LOW priority
                        self.event_logger.log(Some(pkg_name), "Killed due to low memory");
                        freeze_app(pid, grpc_ipc::FreezeMode::ModeKill);
                    }
                }
            }
        }
    }
    
    pub fn get_runtime_stats(&self) -> ffi::RustRuntimeStats {
        let frozen_count = self.runtime_states.iter().filter(|e| matches!(*e.value(), AppState::Frozen(_))).count();
        ffi::RustRuntimeStats {
            total_mem_kb: unsafe { ffi::cpp_get_total_memory_kb() },
            avail_mem_kb: unsafe { ffi::cpp_get_available_memory_kb() },
            frozen_app_count: frozen_count as i32,
            cpu_usage_percent: unsafe { ffi::cpp_get_cpu_usage_percent() },
            network_speed_bps: 0, // Not implemented yet
        }
    }
    
    pub fn get_recent_events(&self, limit: u32) -> Vec<grpc_ipc::EventLog> {
        self.event_logger.get_recent_events(limit).unwrap_or_default()
    }

    // --- Internal Logic ---

    fn handle_app_state_change(&self, event: grpc_ipc::FrameworkEvent, is_foreground: bool) {
        let pkg_name = event.target_package;
        let pid = event.source_package.parse::<i32>().unwrap_or(0);
        if pkg_name.is_empty() || pid <= 0 { return; }

        let old_state = self.runtime_states.get(&pkg_name).map(|r| r.value().clone());

        if is_foreground {
            *self.foreground_package.lock().unwrap() = pkg_name.clone();
            self.event_logger.log(Some(&pkg_name), "App became foreground");
            // Cancel any pending timers for this app
            if let Some(AppState::TemporarilyUnfrozen { refreeze_timer_id, .. }) = old_state {
                unsafe { ffi::cpp_cancel_timer(refreeze_timer_id) };
            }
            unfreeze_app(pid);
            self.runtime_states.insert(pkg_name.clone(), AppState::Foreground(pid));
            
            // AI Data Collection
            if let Some(AppState::Frozen(_)) = old_state {
                let context = self.foreground_package.lock().unwrap().clone();
                self.ml_collector.log_training_data(Some(&context), &pkg_name, "USER_LAUNCH_AFTER_FREEZE", 1);
            }
        } else {
            self.event_logger.log(Some(&pkg_name), "App became background");
            self.runtime_states.insert(pkg_name.clone(), AppState::Background(pid));
            self.add_to_lru(&pkg_name);
            self.adjust_oom_score(&pkg_name, pid);
            
            // Check policy and freeze if necessary
            if let Ok(Some(config)) = self.config_manager.get_app_config(&pkg_name) {
                if config.policy == grpc_ipc::ManagementPolicy::StrictBackground as i32 {
                    self.event_logger.log(Some(&pkg_name), "Frozen by STRICT_BACKGROUND policy");
                    freeze_app(pid, config.freeze_mode.into());
                    self.runtime_states.insert(pkg_name, AppState::Frozen(pid));
                }
            }
        }
    }

    fn handle_screen_on(&self) {
        self.event_logger.log(None, "Screen ON");
        if let Some(timer_id) = self.smart_standby_timer_id.lock().unwrap().take() {
            unsafe { ffi::cpp_cancel_timer(timer_id) };
            self.event_logger.log(None, "Smart Standby cancelled");
        }
    }

    fn handle_screen_off(&self) {
        self.event_logger.log(None, "Screen OFF");
        let standby_delay_ms = 300 * 1000; // 5 minutes, should be configurable
        let timer_id = unsafe { ffi::cpp_create_oneshot_timer(standby_delay_ms) };
        *self.smart_standby_timer_id.lock().unwrap() = Some(timer_id);
        self.event_logger.log(None, &format!("Smart Standby scheduled in {}s", standby_delay_ms / 1000));
    }

    fn handle_standby_timer(&self, timer_id: i64) -> bool {
        let mut id_lock = self.smart_standby_timer_id.lock().unwrap();
        if id_lock.map_or(false, |id| id == timer_id) {
            *id_lock = None;
            self.event_logger.log(None, "Smart Standby triggered, freezing background apps");
            for mut entry in self.runtime_states.iter_mut() {
                if let AppState::Background(pid) = *entry.value() {
                    // TODO: Check for standby-exempt apps
                    freeze_app(pid, grpc_ipc::FreezeMode::ModeSigstop);
                    *entry.value_mut() = AppState::Frozen(pid);
                }
            }
            return true;
        }
        false
    }

    fn handle_refreeze_timer(&self, timer_id: i64) {
        let pkg_to_refreeze = self.runtime_states.iter()
            .find(|entry| matches!(*entry.value(), AppState::TemporarilyUnfrozen { refreeze_timer_id, .. } if refreeze_timer_id == timer_id))
            .map(|entry| entry.key().clone());
            
        if let Some(pkg_name) = pkg_to_refreeze {
            if let Some(mut state) = self.runtime_states.get_mut(&pkg_name) {
                if let AppState::TemporarilyUnfrozen { pid, .. } = *state.value() {
                    self.event_logger.log(Some(&pkg_name), "Re-freezing after temporary exemption");
                    freeze_app(pid, grpc_ipc::FreezeMode::ModeSigstop);
                    *state.value_mut() = AppState::Frozen(pid);
                }
            }
        }
    }

    fn add_to_lru(&self, pkg_name: &str) {
        let mut lru = self.background_lru.lock().unwrap();
        lru.retain(|p| p != pkg_name);
        lru.push_front(pkg_name.to_string());
        if lru.len() > 100 { lru.pop_back(); }
    }

    fn adjust_oom_score(&self, pkg_name: &str, pid: i32) {
        if pid <= 0 { return; }
        let lru = self.background_lru.lock().unwrap();
        let position = lru.iter().position(|p| p == pkg_name).unwrap_or(lru.len());
        
        let base_score = 200;
        let score_step = 50;
        let oom_prio_factor = match self.config_manager.get_app_config(pkg_name) {
            Ok(Some(config)) => match config.oom_priority() {
                grpc_ipc::OomPriority::OomHigh => -2, // less likely to be killed
                grpc_ipc::OomPriority::OomLow => 2,   // more likely to be killed
                _ => 0,
            },
            _ => 0,
        };
        
        let score = base_score + (position as i32 * score_step) + (oom_prio_factor * 100);
        let final_score = std::cmp::min(score, 900); // Cap at 900
        unsafe { ffi::cpp_set_oom_score_adj(pid, final_score) };
    }
}
```

#### **文件: `/Thanatos/daemon/rust/src/lib.rs`**
```rust
// 文件路径: /Thanatos/daemon/rust/src/lib.rs

// --- Crate-level attributes and module imports ---
#![allow(clippy::needless_lifetimes)]
use cxx::UniquePtr;
use std::sync::{Arc};
use once_cell::sync::OnceCell;

// CXX FFI bridge module
#[path = "ffi.rs"]
mod ffi;

// Internal logic modules
mod config_manager;
mod event_logger;
mod execution_manager;
mod logic_controller;
mod ml_collector;
use logic_controller::LogicController;

// gRPC generated types module
mod grpc_generated {
    pub mod thanatos {
        pub mod ipc {
            // This includes the code generated by tonic-build from thanatos.proto
            tonic::include_proto!("thanatos.ipc");
        }
    }
}
use grpc_generated::thanatos::ipc as grpc_ipc;

// Global instance of our controller, initialized once.
static CONTROLLER_INSTANCE: OnceCell<Arc<LogicController>> = OnceCell::new();

// --- FFI Implementations ---

fn rust_init_controller(db_path: &str) -> UniquePtr<LogicController> {
    // Initialize logger, ignoring errors if it's already initialized.
    env_logger::builder()
        .filter_level(log::LevelFilter::Info)
        .try_init()
        .ok();

    log::info!("[Rust] Initializing controller with DB at: {}", db_path);

    let config_manager = Arc::new(config_manager::ConfigManager::new(db_path).expect("Failed to open DB"));
    let db_conn_clone = config_manager.conn.clone();
    
    let event_logger = Arc::new(event_logger::EventLogger::new(db_conn_clone.clone()));
    event_logger.init_db().expect("Failed to init event_log table");
    
    let ml_collector = Arc::new(ml_collector::MLDataCollector::new(db_conn_clone));
    ml_collector.init_db().expect("Failed to init ai_training_data table");

    let controller = LogicController::new(config_manager, event_logger, ml_collector);
    
    UniquePtr::new(controller)
}

fn rust_set_app_config(controller: &LogicController, config: ffi::CxxAppConfig) {
    controller.set_app_config(config.into());
}

fn rust_set_launch_rule(controller: &LogicController, rule: ffi::CxxLaunchRule) {
    controller.set_launch_rule(&rule.into());
}

fn rust_handle_framework_event(controller: &LogicController, event: ffi::CxxFrameworkEvent) {
    controller.handle_framework_event(event.into());
}

fn rust_request_temporary_unfreeze(controller: &LogicController, package_name: &str, reason: i32, duration_ms: i32) {
    let reason_enum = grpc_ipc::UnfreezeReason::from_i32(reason).unwrap_or(grpc_ipc::UnfreezeReason::ReasonUnspecified);
    controller.request_temporary_unfreeze(package_name, reason_enum, duration_ms);
}

fn rust_should_allow_launch(controller: &LogicController, rule: ffi::CxxLaunchRule) -> ffi::CxxLaunchRule {
    let internal_rule: grpc_ipc::LaunchRule = rule.into();
    controller.should_allow_launch(&internal_rule).into()
}

fn rust_on_timer_fired(controller: &LogicController, timer_id: i64) {
    controller.on_timer_fired(timer_id);
}

fn rust_perform_memory_cleanup(controller: &LogicController) {
    controller.perform_memory_cleanup();
}

fn rust_get_runtime_stats(controller: &LogicController) -> ffi::RustRuntimeStats {
    controller.get_runtime_stats()
}

fn rust_get_recent_events(controller: &LogicController, limit: u32) -> Vec<ffi::CxxEventLog> {
    controller.get_recent_events(limit).into_iter().map(Into::into).collect()
}


// --- Type Conversions (From CXX to internal gRPC types and back) ---
// This boilerplate is necessary for type safety across the FFI boundary.

impl From<ffi::CxxAppConfig> for grpc_ipc::AppConfig {
    fn from(c: ffi::CxxAppConfig) -> Self {
        Self {
            package_name: c.package_name,
            policy: c.policy,
            freeze_mode: c.freeze_mode,
            oom_priority: c.oom_priority,
            network_policy: c.network_policy,
            allow_wakeup_for_push: c.allow_wakeup_for_push,
            allow_autostart: c.allow_autostart,
        }
    }
}

impl From<ffi::CxxLaunchRule> for grpc_ipc::LaunchRule {
    fn from(r: ffi::CxxLaunchRule) -> Self {
        Self {
            source_package: r.source_package,
            target_package: r.target_package,
            allowed: r.allowed,
        }
    }
}

impl From<grpc_ipc::LaunchRule> for ffi::CxxLaunchRule {
    fn from(r: grpc_ipc::LaunchRule) -> Self {
        Self {
            source_package: r.source_package,
            target_package: r.target_package,
            allowed: r.allowed,
            ..Default::default()
        }
    }
}

impl From<ffi::CxxFrameworkEvent> for grpc_ipc::FrameworkEvent {
    fn from(e: ffi::CxxFrameworkEvent) -> Self {
        Self {
            event_type: e.event_type,
            source_package: e.source_package,
            target_package: e.target_package,
            timestamp: e.timestamp,
        }
    }
}

impl From<grpc_ipc::EventLog> for ffi::CxxEventLog {
    fn from(log: grpc_ipc::EventLog) -> Self {
        Self {
            timestamp: log.timestamp,
            package_name: log.package_name,
            description: log.event_description,
            ..Default::default()
        }
    }
}
```
---

### **`app` 目录**

#### **文件: `/Thanatos/app/build.gradle.kts`**
```kotlin
// 文件路径: /Thanatos/app/build.gradle.kts

import com.google.protobuf.gradle.*

plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    kotlin("kapt")
    id("com.google.dagger.hilt.android")
    id("com.google.protobuf")
}

android {
    namespace = "io.github.jark006.thanatos"
    compileSdk = 34

    defaultConfig {
        applicationId = "io.github.jark006.thanatos"
        minSdk = 28
        targetSdk = 34
        versionCode = 200
        versionName = "2.0.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
    kotlinOptions {
        jvmTarget = "1.8"
    }
    buildFeatures {
        compose = true
    }
    composeOptions {
        kotlinCompilerExtensionVersion = "1.5.8"
    }
    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }
}

// Protobuf code generation configuration
protobuf {
    protoc {
        artifact = "com.google.protobuf:protoc:3.21.12"
    }
    plugins {
        id("grpc") {
            artifact = "io.grpc:protoc-gen-grpc-java:1.53.0"
        }
    }
    generateProtoTasks {
        all().forEach {
            it.plugins {
                id("grpc") {
                    option("lite") // Use protobuf-javalite, which is optimized for Android
                }
            }
        }
    }
    sourceSets {
        main {
            proto {
                srcDir("../../ipc/proto")
                include("**/*.proto")
            }
        }
    }
}

dependencies {
    // Core Android & Jetpack
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.7.0")
    implementation("androidx.activity:activity-compose:1.8.2")
    implementation(platform("androidx.compose:compose-bom:2024.02.01"))
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-graphics")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0")

    // Hilt for Dependency Injection
    implementation("com.google.dagger:hilt-android:2.51")
    kapt("com.google.dagger:hilt-android-compiler:2.51")
    implementation("androidx.hilt:hilt-navigation-compose:1.2.0")

    // gRPC & Protobuf for Android
    implementation("io.grpc:grpc-okhttp:1.53.0")
    implementation("io.grpc:grpc-protobuf-lite:1.53.0")
    implementation("io.grpc:grpc-stub:1.53.0")
    implementation("javax.annotation:javax.annotation-api:1.3.2")

    // Unix Domain Socket support for gRPC
    api("com.hyperdevs:jdns:2.8.2")

    // Xposed API (compileOnly, as it's provided by the runtime environment)
    compileOnly("de.robv.android.xposed:api:82")

    // Test dependencies
    testImplementation("junit:junit:4.13.2")
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
    androidTestImplementation(platform("androidx.compose:compose-bom:2024.02.01"))
    androidTestImplementation("androidx.compose.ui:ui-test-junit4")
    debugImplementation("androidx.compose.ui:ui-tooling")
    debugImplementation("androidx.compose.ui:ui-test-manifest")
}

kapt {
    correctErrorTypes = true
}
```

#### **文件: `/Thanatos/app/src/main/AndroidManifest.xml`**
```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <application
        android:name=".ThanatosApp"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.Thanatos"
        tools:targetApi="31">
        <activity
            android:name=".ui.MainActivity"
            android:exported="true"
            android:label="@string/app_name"
            android:theme="@style/Theme.Thanatos">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <!-- Metadata for LSPosed to identify this as an Xposed module -->
        <meta-data
            android:name="xposedmodule"
            android:value="true" />
        <meta-data
            android:name="xposeddescription"
            android:value="Thanatos System Orchestrator Sensor" />
        <meta-data
            android:name="xposedminversion"
            android:value="82" />

    </application>

</manifest>
```

#### **文件: `/Thanatos/app/src/main/assets/xposed_init`**
```
io.github.jark006.thanatos.core.hook.ThanatosHookEntry
```

---

### **`app/src/main/java/io/github/jark006/thanatos/`**

#### **文件: `ThanatosApp.kt`**
```kotlin
// 文件路径: /app/src/main/java/io/github/jark006/thanatos/ThanatosApp.kt
package io.github.jark006.thanatos

import android.app.Application
import dagger.hilt.android.HiltAndroidApp

@HiltAndroidApp
class ThanatosApp : Application()
```

---

### **`.../thanatos/core/hook/`**

#### **文件: `ThanatosHookEntry.java`**
```java
// 文件路径: /app/src/main/java/io/github/jark006/thanatos/core/hook/ThanatosHookEntry.java
package io.github.jark006.thanatos.core.hook;

import de.robv.android.xposed.IXposedHookLoadPackage;
import de.robv.android.xposed.XposedBridge;
import de.robv.android.xposed.callbacks.XC_LoadPackage;
import io.github.jark006.thanatos.core.hook.hooker.AppStateHooker;
import io.github.jark006.thanatos.core.hook.hooker.FCMWakeupHooker;
import io.github.jark006.thanatos.core.hook.hooker.InterAppLaunchHooker;
import io.github.jark006.thanatos.core.hook.hooker.PowerManagerHooker;

public class ThanatosHookEntry implements IXposedHookLoadPackage {
    private static final String SYSTEM_SERVER_PACKAGE_NAME = "android";

    @Override
    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable {
        // We only care about hooking the system_server process.
        if (SYSTEM_SERVER_PACKAGE_NAME.equals(lpparam.packageName)) {
            XposedBridge.log("Thanatos-Sensor: Loading into system_server...");

            // Run initialization on a new thread to avoid blocking system_server startup.
            new Thread(() -> {
                // Wait a bit for the system to be reasonably ready.
                try {
                    Thread.sleep(20000); // 20 seconds
                } catch (InterruptedException ignored) {}

                XposedBridge.log("Thanatos-Sensor: Initializing hooks...");
                // Initialize the gRPC singleton. This will establish the connection.
                GrpcService.getInstance();

                // Install all individual hooks.
                AppStateHooker.hook();
                FCMWakeupHooker.hook();
                InterAppLaunchHooker.hook();
                PowerManagerHooker.hook();
                
                XposedBridge.log("Thanatos-Sensor: All hooks initialized.");
            }).start();
        }
    }
}
```

#### **文件: `GrpcService.java`**
```java
// 文件路径: /app/src/main/java/io/github/jark006/thanatos/core/hook/GrpcService.java
package io.github.jark006.thanatos.core.hook;

import com.google.protobuf.Empty;

import java.io.File;
import java.util.concurrent.TimeUnit;

import de.robv.android.xposed.XposedBridge;
import io.grpc.ManagedChannel;
import io.grpc.StatusRuntimeException;
import io.grpc.okhttp.OkHttpChannelBuilder;
import io.grpc.stub.StreamObserver;
import jnr.unixsocket.UnixSocketAddress;
import jnr.unixsocket.UnixSocketChannel;
import thanatos.ipc.FrameworkEvent;
import thanatos.ipc.LaunchRule;
import thanatos.ipc.SystemServiceGrpc;
import thanatos.ipc.TempUnfreezeRequest;
import thanatos.ipc.UnfreezeReason;

public class GrpcService {
    private static final String SOCKET_PATH = "/data/local/tmp/thanatosd.sock";
    private static volatile GrpcService INSTANCE;

    private final ManagedChannel channel;
    private final SystemServiceGrpc.SystemServiceStub asyncStub;
    private final SystemServiceGrpc.SystemServiceBlockingStub blockingStub;
    private StreamObserver<FrameworkEvent> eventStream;

    private GrpcService() {
        XposedBridge.log("Thanatos-Sensor: Initializing gRPC connection...");
        try {
            File socketFile = new File(SOCKET_PATH);
            UnixSocketAddress address = new UnixSocketAddress(socketFile);
            this.channel = OkHttpChannelBuilder
                    .forTarget("unix://" + SOCKET_PATH)
                    .socketFactory((socket, addr) -> UnixSocketChannel.open(address))
                    .usePlaintext()
                    .build();
            
            this.asyncStub = SystemServiceGrpc.newStub(channel);
            this.blockingStub = SystemServiceGrpc.newBlockingStub(channel);
            
            connectEventStream();
            XposedBridge.log("Thanatos-Sensor: gRPC channel established.");
        } catch (Exception e) {
            XposedBridge.log("Thanatos-Sensor: CRITICAL - Failed to create gRPC channel.");
            XposedBridge.log(e);
            this.channel = null;
            this.asyncStub = null;
            this.blockingStub = null;
        }
    }

    public static GrpcService getInstance() {
        if (INSTANCE == null) {
            synchronized (GrpcService.class) {
                if (INSTANCE == null) {
                    INSTANCE = new GrpcService();
                }
            }
        }
        return INSTANCE;
    }

    private void connectEventStream() {
        if (asyncStub == null) return;
        eventStream = asyncStub.pushFrameworkEvents(new StreamObserver<>() {
            @Override
            public void onNext(Empty value) { /* Server ACK, do nothing */ }
            @Override
            public void onError(Throwable t) {
                XposedBridge.log("Thanatos-Sensor: Event stream error: " + t.getMessage());
                // Simple reconnect logic
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException ignored) {}
                connectEventStream();
            }
            @Override
            public void onCompleted() {
                XposedBridge.log("Thanatos-Sensor: Event stream completed by server.");
            }
        });
    }

    public void pushEvent(FrameworkEvent event) {
        if (eventStream != null) {
            try {
                eventStream.onNext(event);
            } catch (Exception e) {
                XposedBridge.log("Thanatos-Sensor: Failed to push event: " + e.getMessage());
                // Try to reconnect
                connectEventStream();
            }
        }
    }

    public boolean requestTemporaryUnfreeze(String packageName, UnfreezeReason reason, int durationMs) {
        if (blockingStub == null) return false;

        TempUnfreezeRequest request = TempUnfreezeRequest.newBuilder()
                .setPackageName(packageName)
                .setReason(reason)
                .setDurationMs(durationMs)
                .build();
        
        try {
            blockingStub.withDeadlineAfter(3, TimeUnit.SECONDS).requestTemporaryUnfreeze(request);
            return true;
        } catch (StatusRuntimeException e) {
            XposedBridge.log("Thanatos-Sensor: requestTemporaryUnfreeze RPC failed: " + e.getStatus());
            return false;
        }
    }
    
    public LaunchRule shouldAllowLaunch(LaunchRule rule) {
        if (blockingStub == null) {
            return LaunchRule.newBuilder(rule).setAllowed(true).build(); // Fail-safe: allow
        }
        try {
            return blockingStub.withDeadlineAfter(3, TimeUnit.SECONDS).shouldAllowLaunch(rule);
        } catch (Exception e) {
            XposedBridge.log("Thanatos-Sensor: shouldAllowLaunch RPC failed: " + e.getMessage());
            return LaunchRule.newBuilder(rule).setAllowed(true).build(); // Fail-safe: allow
        }
    }
}
```

### **`.../thanatos/core/hook/hooker/`**

#### **文件: `AppStateHooker.java`**
```java
// 文件路径: /app/src/main/java/io/github/jark006/thanatos/core/hook/hooker/AppStateHooker.java
package io.github.jark006.thanatos.core.hook.hooker;

import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;

import android.app.ActivityManager;
import de.robv.android.xposed.XC_MethodHook;
import de.robv.android.xposed.XposedBridge;
import de.robv.android.xposed.XposedHelpers;
import io.github.jark006.thanatos.core.hook.GrpcService;
import thanatos.ipc.FrameworkEvent;

public class AppStateHooker {
    private static final String AMS_CLASS = "com.android.server.am.ActivityManagerService";

    public static void hook() {
        try {
            findAndHookMethod(AMS_CLASS, null, "setProcessState",
                    "com.android.server.am.ProcessRecord", int.class, boolean.class, int.class,
                    new XC_MethodHook() {
                        @Override
                        protected void afterHookedMethod(MethodHookParam param) {
                            Object processRecord = param.args[0];
                            if (processRecord == null) return;
                            
                            int pid = (int) XposedHelpers.getObjectField(processRecord, "pid");
                            String pkgName = (String) XposedHelpers.getObjectField(processRecord, "stringName");
                            int newState = (int) param.args[1];

                            if (pkgName == null || pid == 0) return;
                            
                            // Check if it's a user application (uid >= 10000)
                            int uid = (int) XposedHelpers.getObjectField(processRecord, "uid");
                            if (uid < 10000) return;

                            boolean isForeground = newState <= ActivityManager.PROCESS_STATE_TOP;

                            FrameworkEvent.EventType eventType = isForeground
                                    ? FrameworkEvent.EventType.APP_FOREGROUND
                                    : FrameworkEvent.EventType.APP_BACKGROUND;

                            FrameworkEvent event = FrameworkEvent.newBuilder()
                                    .setEventType(eventType)
                                    .setTargetPackage(pkgName)
                                    .setSourcePackage(String.valueOf(pid)) // Use source for PID
                                    .setTimestamp(System.currentTimeMillis())
                                    .build();
                            
                            GrpcService.getInstance().pushEvent(event);
                        }
                    });
            XposedBridge.log("Thanatos-Sensor: AppStateHooker installed successfully.");
        } catch (Throwable t) {
            XposedBridge.log("Thanatos-Sensor: Failed to install AppStateHooker.");
            XposedBridge.log(t);
        }
    }
}
```

#### **文件: `FCMWakeupHooker.java`**
```java
// 文件路径: /app/src/main/java/io/github/jark006/thanatos/core/hook/hooker/FCMWakeupHooker.java
package io.github.jark006.thanatos.core.hook.hooker;

import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;

import android.content.Intent;
import de.robv.android.xposed.XC_MethodHook;
import de.robv.android.xposed.XposedBridge;
import io.github.jark006.thanatos.core.hook.GrpcService;
import thanatos.ipc.UnfreezeReason;

public class FCMWakeupHooker {
    private static final String AMS_CLASS = "com.android.server.am.ActivityManagerService";
    private static final String GCM_RECEIVE_ACTION = "com.google.android.c2dm.intent.RECEIVE";
    private static final String FCM_MESSAGING_EVENT_ACTION = "com.google.firebase.MESSAGING_EVENT";

    public static void hook() {
        try {
            findAndHookMethod(AMS_CLASS, null, "startService",
                    "android.app.IApplicationThread", Intent.class, String.class,
                    boolean.class, String.class, int.class,
                    new XC_MethodHook() {
                        @Override
                        protected void beforeHookedMethod(MethodHookParam param) {
                            Intent intent = (Intent) param.args[1];
                            if (intent == null || intent.getComponent() == null) return;
                            
                            String targetPackage = intent.getComponent().getPackageName();
                            String action = intent.getAction();

                            boolean isFcmWakeup = GCM_RECEIVE_ACTION.equals(action) || FCM_MESSAGING_EVENT_ACTION.equals(action);

                            if (isFcmWakeup) {
                                XposedBridge.log("Thanatos-Sensor: Detected FCM wakeup for " + targetPackage);
                                
                                boolean unfreezeSuccess = GrpcService.getInstance().requestTemporaryUnfreeze(
                                        targetPackage,
                                        UnfreezeReason.FCM_PUSH,
                                        30000 // Unfreeze for 30 seconds
                                );
                                
                                if (!unfreezeSuccess) {
                                    // This part is tricky. Blocking might not be the best idea.
                                    // For now, we just log it. A more advanced policy would be needed.
                                    XposedBridge.log("Thanatos-Sensor: Unfreeze request for " + targetPackage + " failed, but allowing service start anyway.");
                                }
                            }
                        }
                    });
            XposedBridge.log("Thanatos-Sensor: FCMWakeupHooker installed successfully.");
        } catch (Throwable t) {
            XposedBridge.log("Thanatos-Sensor: Failed to install FCMWakeupHooker.");
            XposedBridge.log(t);
        }
    }
}
```

#### **文件: `InterAppLaunchHooker.java`**
```java
// 文件路径: /app/src/main/java/io/github/jark006/thanatos/core/hook/hooker/InterAppLaunchHooker.java
package io.github.jark006.thanatos.core.hook.hooker;

import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;

import android.content.Intent;
import de.robv.android.xposed.XC_MethodHook;
import de.robv.android.xposed.XposedBridge;
import io.github.jark006.thanatos.core.hook.GrpcService;
import thanatos.ipc.LaunchRule;

public class InterAppLaunchHooker {
    private static final String AMS_CLASS = "com.android.server.am.ActivityManagerService";
    private static final String SYSTEM_PACKAGE = "android";

    public static void hook() {
        try {
            findAndHookMethod(AMS_CLASS, null, "startService",
                    "android.app.IApplicationThread", Intent.class, String.class,
                    boolean.class, String.class, int.class,
                    new XC_MethodHook() {
                        @Override
                        protected void beforeHookedMethod(MethodHookParam param) {
                            Intent intent = (Intent) param.args[1];
                            String callingPackage = (String) param.args[4];
                            
                            if (intent == null || intent.getComponent() == null || callingPackage == null) return;
                            
                            String targetPackage = intent.getComponent().getPackageName();
                            
                            if (callingPackage.equals(targetPackage) || callingPackage.equals(SYSTEM_PACKAGE)) return;
                            
                            // Let FCMWakeupHooker handle its specific intents first
                            String action = intent.getAction();
                            if ("com.google.android.c2dm.intent.RECEIVE".equals(action) || "com.google.firebase.MESSAGING_EVENT".equals(action)) {
                                return;
                            }
                            
                            LaunchRule rule = LaunchRule.newBuilder()
                                    .setSourcePackage(callingPackage)
                                    .setTargetPackage(targetPackage)
                                    .build();
                            
                            LaunchRule resultRule = GrpcService.getInstance().shouldAllowLaunch(rule);
                            
                            if (resultRule != null && !resultRule.getAllowed()) {
                                XposedBridge.log("Thanatos-Sensor: Launch BLOCKED by rule: " + callingPackage + " -> " + targetPackage);
                                param.setResult(null); // Block the service start
                            }
                        }
                    });
            XposedBridge.log("Thanatos-Sensor: InterAppLaunchHooker installed successfully.");
        } catch (Throwable t) {
            XposedBridge.log("Thanatos-Sensor: Failed to install InterAppLaunchHooker.");
            XposedBridge.log(t);
        }
    }
}
```

#### **文件: `PowerManagerHooker.java`**
```java
// 文件路径: /app/src/main/java/io/github/jark006/thanatos/core/hook/hooker/PowerManagerHooker.java
package io.github.jark006.thanatos.core.hook.hooker;

import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;

import de.robv.android.xposed.XC_MethodHook;
import de.robv.android.xposed.XposedBridge;
import io.github.jark006.thanatos.core.hook.GrpcService;
import thanatos.ipc.FrameworkEvent;

public class PowerManagerHooker {
    private static final String PMS_CLASS = "com.android.server.power.PowerManagerService";

    public static void hook() {
        try {
            findAndHookMethod(PMS_CLASS, null, "goToSleep",
                    long.class, int.class, int.class,
                    new XC_MethodHook() {
                        @Override
                        protected void afterHookedMethod(MethodHookParam param) {
                            FrameworkEvent event = FrameworkEvent.newBuilder()
                                    .setEventType(FrameworkEvent.EventType.SCREEN_OFF)
                                    .setTimestamp(System.currentTimeMillis())
                                    .build();
                            GrpcService.getInstance().pushEvent(event);
                        }
                    });

            findAndHookMethod(PMS_CLASS, null, "wakeUp",
                    long.class, int.class, String.class, String.class,
                    new XC_MethodHook() {
                        @Override
                        protected void afterHookedMethod(MethodHookParam param) {
                             FrameworkEvent event = FrameworkEvent.newBuilder()
                                    .setEventType(FrameworkEvent.EventType.SCREEN_ON)
                                    .setTimestamp(System.currentTimeMillis())
                                    .build();
                            GrpcService.getInstance().pushEvent(event);
                        }
                    });
            XposedBridge.log("Thanatos-Sensor: PowerManagerHooker installed successfully.");
        } catch (Throwable t) {
            XposedBridge.log("Thanatos-Sensor: Failed to install PowerManagerHooker.");
            XposedBridge.log(t);
        }
    }
}
```

---

### **`.../thanatos/data/`**

#### **文件: `.../grpc/GrpcModule.kt`**
```kotlin
// 文件路径: /app/src/main/java/io/github/jark006/thanatos/data/grpc/GrpcModule.kt
package io.github.jark006.thanatos.data.grpc

import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import io.grpc.ManagedChannel
import io.grpc.okhttp.OkHttpChannelBuilder
import jnr.unixsocket.UnixSocketAddress
import jnr.unixsocket.UnixSocketChannel
import thanatos.ipc.AppControlServiceGrpc
import thanatos.ipc.DashboardServiceGrpc
import thanatos.ipc.SystemServiceGrpc
import java.io.File
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object GrpcModule {
    private const val SOCKET_PATH = "/data/local/tmp/thanatosd.sock"

    @Provides
    @Singleton
    fun provideManagedChannel(): ManagedChannel {
        val socketFile = File(SOCKET_PATH)
        val address = UnixSocketAddress(socketFile)

        return OkHttpChannelBuilder
            .forTarget("unix://$SOCKET_PATH")
            .socketFactory { _, _ -> UnixSocketChannel.open(address) }
            .usePlaintext()
            .build()
    }
    
    @Provides
    @Singleton
    fun provideDashboardServiceStub(channel: ManagedChannel): DashboardServiceGrpc.DashboardServiceStub {
        return DashboardServiceGrpc.newStub(channel)
    }
    
    @Provides
    @Singleton
    fun provideAppControlServiceStub(channel: ManagedChannel): AppControlServiceGrpc.AppControlServiceStub {
        return AppControlServiceGrpc.newStub(channel)
    }

    // Add other stubs if needed
}
```

#### **文件: `.../repository/DashboardRepository.kt`**
```kotlin
// 文件路径: /app/src/main/java/io/github/jark006/thanatos/data/repository/DashboardRepository.kt
package io.github.jark006.thanatos.data.repository

import com.google.protobuf.Empty
import io.grpc.stub.StreamObserver
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.flowOn
import thanatos.ipc.DashboardServiceGrpc
import thanatos.ipc.EventLog
import thanatos.ipc.RuntimeStats
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class DashboardRepository @Inject constructor(
    private val dashboardStub: DashboardServiceGrpc.DashboardServiceStub
) {
    fun getRuntimeStatsStream(): Flow<RuntimeStats> = callbackFlow {
        val request = Empty.getDefaultInstance()
        val observer = object : StreamObserver<RuntimeStats> {
            override fun onNext(value: RuntimeStats) {
                trySend(value)
            }
            override fun onError(t: Throwable) {
                close(t)
            }
            override fun onCompleted() {
                close()
            }
        }
        val call = dashboardStub.streamRuntimeStats(request, observer)
        awaitClose { 
            // Attempt to cancel the call when the flow is cancelled
            call.cancel("Flow collection cancelled", null)
        }
    }.flowOn(Dispatchers.IO)
    
    fun getRecentEventsStream(): Flow<EventLog> = callbackFlow {
        val request = Empty.getDefaultInstance()
        val observer = object: StreamObserver<EventLog> {
            override fun onNext(value: EventLog) {
                trySend(value)
            }
            override fun onError(t: Throwable) {
                close(t)
            }
            override fun onCompleted() {
                close()
            }
        }
        val call = dashboardStub.getRecentEvents(request, observer)
        awaitClose {
            call.cancel("Flow collection cancelled", null)
        }
    }.flowOn(Dispatchers.IO)
}
```

---

### **`.../thanatos/ui/`**

#### **文件: `MainActivity.kt`**
```kotlin
// 文件路径: /app/src/main/java/io/github/jark006/thanatos/ui/MainActivity.kt
package io.github.jark006.thanatos.ui

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.ui.Modifier
import dagger.hilt.android.AndroidEntryPoint
import io.github.jark006.thanatos.ui.screen.dashboard.DashboardScreen
import io.github.jark006.thanatos.ui.theme.ThanatosTheme

@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            ThanatosTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    DashboardScreen()
                }
            }
        }
    }
}
```

#### **文件: `.../screen/dashboard/DashboardScreen.kt`**
```kotlin
// 文件路径: /app/src/main/java/io/github/jark006/thanatos/ui/screen/dashboard/DashboardScreen.kt
package io.github.jark006.thanatos.ui.screen.dashboard

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import thanatos.ipc.EventLog
import thanatos.ipc.RuntimeStats
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DashboardScreen(viewModel: DashboardViewModel = hiltViewModel()) {
    val stats by viewModel.runtimeStats.collectAsState()
    val events by viewModel.recentEvents.collectAsState()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Thanatos Dashboard") },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primaryContainer,
                    titleContentColor = MaterialTheme.colorScheme.primary,
                )
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(horizontal = 16.dp)
        ) {
            StatsDisplay(stats = stats)
            Spacer(modifier = Modifier.height(16.dp))
            Text("Recent Events", style = MaterialTheme.typography.titleMedium)
            Divider(modifier = Modifier.padding(vertical = 8.dp))
            EventLogList(events = events)
        }
    }
}

@Composable
fun StatsDisplay(stats: RuntimeStats?) {
    Card(modifier = Modifier.fillMaxWidth()) {
        if (stats != null) {
            Row(
                modifier = Modifier.fillMaxWidth().padding(16.dp),
                horizontalArrangement = Arrangement.SpaceAround
            ) {
                StatItem("CPU", "${"%.1f".format(stats.cpuUsagePercent)}%")
                StatItem("Memory", "${stats.availMemKb / 1024} / ${stats.totalMemKb / 1024} MB")
                StatItem("Frozen", stats.frozenAppCount.toString())
            }
        } else {
            Box(modifier = Modifier.fillMaxWidth().padding(16.dp), contentAlignment = Alignment.Center) {
                CircularProgressIndicator()
            }
        }
    }
}

@Composable
fun StatItem(label: String, value: String) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(text = value, fontWeight = FontWeight.Bold, fontSize = 18.sp)
        Text(text = label, style = MaterialTheme.typography.labelSmall)
    }
}

@Composable
fun EventLogList(events: List<EventLog>) {
    LazyColumn(modifier = Modifier.fillMaxSize()) {
        if (events.isEmpty()) {
            item {
                Box(modifier = Modifier.fillParentMaxSize(), contentAlignment = Alignment.Center) {
                    Text("No events logged yet.")
                }
            }
        } else {
            items(events) { event ->
                EventLogItem(event = event)
                Spacer(modifier = Modifier.height(8.dp))
            }
        }
    }
}

@Composable
fun EventLogItem(event: EventLog) {
    val formatter = SimpleDateFormat("HH:mm:ss", Locale.getDefault())
    val time = formatter.format(Date(event.timestamp))

    Row(verticalAlignment = Alignment.CenterVertically) {
        Text(
            text = time,
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.primary
        )
        Spacer(modifier = Modifier.width(8.dp))
        Column {
            if (event.packageName.isNotEmpty()) {
                Text(
                    text = event.packageName,
                    style = MaterialTheme.typography.labelMedium,
                    fontWeight = FontWeight.Bold
                )
            }
            Text(
                text = event.eventDescription,
                style = MaterialTheme.typography.bodyMedium
            )
        }
    }
}
```

#### **文件: `.../screen/dashboard/DashboardViewModel.kt`**
```kotlin
// 文件路径: /app/src/main/java/io/github/jark006/thanatos/ui/screen/dashboard/DashboardViewModel.kt
package io.github.jark006.thanatos.ui.screen.dashboard

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import dagger.hilt.android.lifecycle.HiltViewModel
import io.github.jark006.thanatos.data.repository.DashboardRepository
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.stateIn
import thanatos.ipc.EventLog
import thanatos.ipc.RuntimeStats
import javax.inject.Inject

@HiltViewModel
class DashboardViewModel @Inject constructor(
    dashboardRepository: DashboardRepository
) : ViewModel() {

    val runtimeStats: StateFlow<RuntimeStats?> = dashboardRepository.getRuntimeStatsStream()
        .catch { e ->
            println("ViewModel: Error collecting stats: ${e.message}")
            emit(null)
        }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = null
        )
    
    val recentEvents: StateFlow<List<EventLog>> = dashboardRepository.getRecentEventsStream()
        .catch { e ->
            println("ViewModel: Error collecting events: ${e.message}")
            emit(emptyList())
        }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )
}
```

#### **文件: `.../theme/Theme.kt` (and others)**
这些是 Android Studio 自动生成的标准主题文件，在此不再赘述。

---
